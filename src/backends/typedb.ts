
import { flatMap, fromPairs, toPairs, uniq, sortBy, omit, size } from "lodash";
import {

  EnumDefinition,
  TableDefinition,
  ColumnDefinition,

} from "../adapters/types";
import {TYPEDB_TYPEMAP, isReservedWord} from "../typemaps/typedb-typemap"
import { BuildContext } from "../generator";

import {
  applyConfigToCoreference,
  invalidTypeDBOverlaps,
  invalidOverlaps,
  attributeOverlapGrouping,
} from "../coreference";
import { pretty } from "../formatters";

//------------------------------------------------------------------------------


const normalizeName = (name: string): string =>
isReservedWord(name) ? `${name}_` : name;

//------------------------------------------------------------------------------



const typing = (
  { config, enums }: BuildContext,
  { udtName }: ColumnDefinition
): string => {
  const type = TYPEDB_TYPEMAP[udtName];
  if (type && !["unknown"].includes(type)) {
    return type;
  }

  const enumDefinition = enums.find(({ name }) => name === udtName);
  if (enumDefinition) {
    const enumType = config.formatEnumName(enumDefinition.name);
    return `string; # enum: ${enumType}`;
  }

  const warning = `Type [${udtName} has been mapped to [any] because no specific type has been found.`;
  if (config.throwOnMissingType) {
    throw new Error(warning);
  }
  console.warn(warning);
  return "any";
};

//------------------------------------------------------------------------------

const castHeader = async ({ config }: BuildContext): Promise<string> => `
################################################################################
#
# AUTO-GENERATED FILE @ ${config.timestamp} - DO NOT EDIT!
#
# This file was automatically generated by schemats v.${config.version}
# $ ${config.commandFromCLI}
#
################################################################################

${config.database}-entity sub entity, abstract;
${config.database}-relation sub relation, abstract;
${config.database}-attribute sub attribute, abstract;`;

//------------------------------------------------------------------------------

const Attribute = {
  name: ({ config }: BuildContext, { name }: ColumnDefinition): string =>
    normalizeName(config.formatColumnName(name)),

  type: ({ config }: BuildContext, record: ColumnDefinition): string =>
    `${config.database.toLowerCase()}-attribute`,
};

const Entity = {
  name: ({ config }: BuildContext, { name }: TableDefinition): string =>
    normalizeName(config.formatTableName(name)),

  type: ({ config }: BuildContext, record: TableDefinition): string =>
    `${config.database.toLowerCase()}-entity`,
};

const castEntity = (context: BuildContext) => (record: TableDefinition) => {
  const name = Entity.name(context, record);
  const attributes = Object.values(record.columns).map(
    (column) =>
      `${Attribute.name(context, column)} sub ${Attribute.type(
        context,
        column
      )}, value ${typing(context, column)};`
  );
  const fields = Object.values(record.columns).map(
    (column) => `  , owns ${Attribute.name(context, column)}`
  );
  return `${name} sub ${Entity.type(context, record)}\n${fields.join(
    "\n"
  )}\n;\n${attributes.join("\n")}`;
};

//------------------------------------------------------------------------------

const castOverlapHeader = (overlaps: Record<string, string[]>) => `
################################################################################
# ERRORS: INVALID TYPEDB COLLISIONS
################################################################################
${pretty(invalidTypeDBOverlaps(overlaps))
  .split("\n")
  .map((line) => `# ${line}`)
  .join("\n")}
#===============================================================================
# WARNING: INVALID TYPE COLLISIONS
#===============================================================================
${pretty(invalidOverlaps(overlaps))
  .split("\n")
  .map((line) => `# ${line}`)
  .join("\n")}
#-------------------------------------------------------------------------------
# Overlapping keys
#-------------------------------------------------------------------------------
${pretty(overlaps)
  .split("\n")
  .map((line) => `# ${line}`)
  .join("\n")}
################################################################################
`;

const overlapHeader = ({ config, tables }: BuildContext) => {
  const userOverlaps = applyConfigToCoreference(config, tables);
  if (!config.ignoreFieldCollisions.includes("*") && size(userOverlaps) > 0) {
    return castOverlapHeader(userOverlaps);
  }
  return `
#-------------------------------------------------------------------------------
`;
};

export const typedbOfSchema = async (context: BuildContext) => {
  const header = await castHeader(context);
  const entities = flatMap(Object.values(context.tables), castEntity(context));
  const overlaps = overlapHeader(context);

  return [header, overlaps, entities.join("\n\n")].join("\n");
};
