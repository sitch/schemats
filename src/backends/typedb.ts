import { flatMap, fromPairs, toPairs, uniq, sortBy, omit, size } from "lodash";
import { Config } from "../config";
import {
  BuildContext,
  EnumDefinition,
  TableDefinition,
  ColumnDefinition,
  ForeignKey,
} from "../adapters/types";
import { castTypeDBType, isReservedWord } from "../typemaps/typedb-typemap";

import {
  applyConfigToCoreference,
  invalidTypeDBOverlaps,
  invalidOverlaps,
  attributeOverlapGrouping,
} from "../coreference";
import { pretty } from "../formatters";

//------------------------------------------------------------------------------

const normalizeName = (name: string): string =>
  isReservedWord(name) ? `${name}_` : name;

//------------------------------------------------------------------------------

const castHeader = async ({ config }: BuildContext): Promise<string> => `
################################################################################
#
# AUTO-GENERATED FILE @ ${config.timestamp} - DO NOT EDIT!
#
# This file was automatically generated by schemats v.${config.version}
# $ ${config.commandFromCLI}
#
################################################################################

${config.database}-entity sub entity, abstract;
${config.database}-relation sub relation, abstract;
${config.database}-attribute sub attribute, abstract;`;

//------------------------------------------------------------------------------

const banner = (name: string) => `${divider()}# ${name}${divider()}`;
const divider = () => `
#-------------------------------------------------------------------------------
`;

const castCoreferenceHeader = (overlaps: Record<string, string[]>) => `
################################################################################
# ERRORS: INVALID TYPEDB COLLISIONS
################################################################################
${pretty(invalidTypeDBOverlaps(overlaps))
  .split("\n")
  .map((line) => `# ${line}`)
  .join("\n")}
#===============================================================================
# WARNING: INVALID TYPE COLLISIONS
#===============================================================================
${pretty(invalidOverlaps(overlaps))
  .split("\n")
  .map((line) => `# ${line}`)
  .join("\n")}
#-------------------------------------------------------------------------------
# Overlapping keys
#-------------------------------------------------------------------------------
${pretty(overlaps)
  .split("\n")
  .map((line) => `# ${line}`)
  .join("\n")}
################################################################################
`;

const prefix = (config: Config) => {
  return config.database.toLowerCase();
};

//------------------------------------------------------------------------------

const Entity = {
  name: ({ config }: BuildContext, { name }: TableDefinition): string => {
    return normalizeName(config.formatEntityName(name));
  },
  type: ({ config }: BuildContext, table: TableDefinition): string => {
    return `${prefix(config)}-entity`;
  },
  field:
    (context: BuildContext) =>
    (column: ColumnDefinition): string => {
      const name = Attribute.name(context, column);
      return `  , owns ${name}`;
    },
};

const castEntity = (context: BuildContext) => (record: TableDefinition) => {
  const name = Entity.name(context, record);
  const type = Entity.type(context, record);
  const columns = Object.values(record.columns);

  const fields = columns.map(Entity.field(context));
  const attributes = columns.map(castAttribute(context));

  return `${name} sub ${type}\n${fields.join("\n")}\n;\n${attributes.join(
    "\n"
  )}`;
};

//------------------------------------------------------------------------------

const Attribute = {
  name: ({ config }: BuildContext, { name }: ColumnDefinition): string => {
    return normalizeName(config.formatAttributeName(name));
  },
  type: ({ config }: BuildContext, record: ColumnDefinition): string => {
    return `${prefix(config)}-attribute`;
  },
};

const castAttribute = (context: BuildContext) => (column: ColumnDefinition) => {
  const name = Attribute.name(context, column);
  const type = Attribute.type(context, column);
  const value = castTypeDBType(context, column);
  return `${name} sub ${type}, value ${value};`;
};

//------------------------------------------------------------------------------

const Relation = {
  name: (
    { config }: BuildContext,
    {
      table_name,
      column_name,
      foreign_table_name,
      foreign_column_name,
      conname,
    }: ForeignKey
  ): string => {
    const tableSource = config.formatRelationName(table_name);
    const attributeSource = config.formatRelationName(column_name);
    const tableDest = config.formatRelationName(foreign_table_name);
    const attributeDest = config.formatRelationName(foreign_column_name);

    return normalizeName(
      `${tableSource}-${attributeSource}-${tableDest}-${attributeDest}`
    );
  },
  type: ({ config }: BuildContext, table: ForeignKey): string => {
    return `${prefix(config)}-relation`;
  },
};

const castRelation = (context: BuildContext) => (record: ForeignKey) => {
  const { config } = context;
  const {
    table_name,
    column_name,
    foreign_table_name,
    foreign_column_name,
    conname,
  } = record;

  const name = Relation.name(context, record);
  const type = Relation.type(context, record);
  const comment = `# Source: '${config.schema}.${conname}'`;
  const relations = [
    `  , owns ${config.formatAttributeName(column_name)}`,
    `  , owns ${config.formatAttributeName(foreign_column_name)}`,
    `  , relates ${config.formatEntityName(table_name)}`,
    `  , relates ${config.formatEntityName(foreign_table_name)}`,
  ];

  return `${comment}\n${name} sub ${type}\n${relations.sort().join("\n")}\n;`;
};

//------------------------------------------------------------------------------

export const typedbOfSchema = async (context: BuildContext) => {
  const tables = Object.values(context.tables);
  const foreignKeys = Object.values(context.foreignKeys).flat();
  const header = await castHeader(context);
  const entities = flatMap(tables, castEntity(context));
  const relationships = flatMap(foreignKeys, castRelation(context));

  const userOverlaps = applyConfigToCoreference(context);

  return [
    header,
    size(userOverlaps) > 0 ? castCoreferenceHeader(userOverlaps) : "",
    banner("Entities"),
    entities.join("\n\n"),
    banner("Relations"),
    size(foreignKeys) > 0 ? relationships.join("\n\n") : divider(),
    "",
  ].join("\n");
};
