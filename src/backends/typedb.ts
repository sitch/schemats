import { flatMap, fromPairs, toPairs, uniq, sortBy, omit, size } from "lodash";
import {
  EnumDefinition,
  TableDefinition,
  ColumnDefinition,
} from "../adapters/types";
import { castTypeDBType, isReservedWord } from "../typemaps/typedb-typemap";
import { BuildContext } from "../generator";

import {
  applyConfigToCoreference,
  invalidTypeDBOverlaps,
  invalidOverlaps,
  attributeOverlapGrouping,
} from "../coreference";
import { pretty } from "../formatters";

//------------------------------------------------------------------------------

const normalizeName = (name: string): string =>
  isReservedWord(name) ? `${name}_` : name;

//------------------------------------------------------------------------------

const castHeader = async ({ config }: BuildContext): Promise<string> => `
################################################################################
#
# AUTO-GENERATED FILE @ ${config.timestamp} - DO NOT EDIT!
#
# This file was automatically generated by schemats v.${config.version}
# $ ${config.commandFromCLI}
#
################################################################################

${config.database}-entity sub entity, abstract;
${config.database}-relation sub relation, abstract;
${config.database}-attribute sub attribute, abstract;`;

//------------------------------------------------------------------------------

const castCoreferenceHeader = (overlaps: Record<string, string[]>) => `
################################################################################
# ERRORS: INVALID TYPEDB COLLISIONS
################################################################################
${pretty(invalidTypeDBOverlaps(overlaps))
  .split("\n")
  .map((line) => `# ${line}`)
  .join("\n")}
#===============================================================================
# WARNING: INVALID TYPE COLLISIONS
#===============================================================================
${pretty(invalidOverlaps(overlaps))
  .split("\n")
  .map((line) => `# ${line}`)
  .join("\n")}
#-------------------------------------------------------------------------------
# Overlapping keys
#-------------------------------------------------------------------------------
${pretty(overlaps)
  .split("\n")
  .map((line) => `# ${line}`)
  .join("\n")}
################################################################################
`;

//------------------------------------------------------------------------------

const Attribute = {
  name: ({ config }: BuildContext, { name }: ColumnDefinition): string =>
    normalizeName(config.formatColumnName(name)),

  type: ({ config }: BuildContext, record: ColumnDefinition): string =>
    `${config.database.toLowerCase()}-attribute`,
};

const castAttribute = (context: BuildContext) => (column: ColumnDefinition) => {
  const name = Attribute.name(context, column);
  const type = Attribute.type(context, column);
  const value = castTypeDBType(context, column);
  return `${name} sub ${type}, value ${value};`;
};

//------------------------------------------------------------------------------

const Entity = {
  name: ({ config }: BuildContext, { name }: TableDefinition): string =>
    normalizeName(config.formatTableName(name)),

  type: ({ config }: BuildContext, table: TableDefinition): string =>
    `${config.database.toLowerCase()}-entity`,

  field:
    (context: BuildContext) =>
    (column: ColumnDefinition): string =>
      `  , owns ${Attribute.name(context, column)}`,
};

const castEntity = (context: BuildContext) => (record: TableDefinition) => {
  const name = Entity.name(context, record);
  const type = Entity.type(context, record);
  const columns = Object.values(record.columns);

  const fields = columns.map(Entity.field(context));
  const attributes = columns.map(castAttribute(context));

  return `${name} sub ${type}\n${fields.join("\n")}\n;\n${attributes.join(
    "\n"
  )}`;
};

//------------------------------------------------------------------------------

const divider = () => `

#-------------------------------------------------------------------------------
`;

export const typedbOfSchema = async (context: BuildContext) => {
  const tables = Object.values(context.tables);
  const header = await castHeader(context);
  const entities = flatMap(tables, castEntity(context));

  const userOverlaps = applyConfigToCoreference(context);

  return [
    header,

    size(userOverlaps) > 0 ? castCoreferenceHeader(userOverlaps) : divider(),

    entities.join("\n\n"),
  ].join("\n");
};
