import { Config } from "../config";
import { Database } from "../schema-interfaces";
import { flatMap, fromPairs, uniq, sortBy, omit, size } from "lodash";
import {
  EnumDefinition,
  TableDefinition,
  ColumnDefinition,
  EnumDefinitions,
  TableDefinitions,
  CustomType,
  CustomTypes,
} from "../schema-interfaces";

//------------------------------------------------------------------------------

const RESERVED_WORDS = new Set([
  // datatypes
  "boolean",
  "datetime",
  "double",
  "long",
  "string",

  // 	"COUNT",
  // "MAX",
  // "MEAN",
  // "MEDIAN",
  // "MIN",
  // "STD",
  // "SUM",

  "type",

  // query
  "match",
  "get",
  "define",
  "undefine",
  "delete",
  "compute",
  "insert",

  "abstract",
  "sub",
  "attribute",
  "entity",
  "relation",
  "thing",
  "role",
  "rule",

  "owns",
  "relates",
  "plays",

  "value",
  "isa",
]);
const normalizeName = (name: string): string =>
  RESERVED_WORDS.has(name) ? `${name}_` : name;

//------------------------------------------------------------------------------

const MYSQL_TYPES: Record<string, string> = {
  char: "string",
  varchar: "string",
  text: "string",
  tinytext: "string",
  mediumtext: "string",
  longtext: "string",
  time: "string",
  geometry: "string",
  set: "string",
  enum: "string",
  integer: "long",
  int: "long",
  smallint: "long",
  mediumint: "long",
  bigint: "long",
  double: "double",
  decimal: "double",
  numeric: "double",
  float: "double",
  year: "long",
  tinyint: "boolean",
  json: "JSON",
  date: "datetime",
  datetime: "datetime",
  timestamp: "datetime",
  tinyblob: "string",
  mediumblob: "string",
  longblob: "string",
  blob: "string",
  binary: "string",
  varbinary: "string",
  bit: "string",
};

const POSTGRES_TYPES: Record<string, string> = {
  bpchar: "string",
  char: "string",
  varchar: "string",
  text: "string",
  citext: "string",
  uuid: "string",
  bytea: "string",
  inet: "string",
  time: "datetime",
  timetz: "datetime",
  interval: "string",
  tsvector: "string",
  mol: "string",
  bit: "string",
  bfp: "string",
  name: "string",
  int2: "long",
  int4: "long",
  int8: "long",
  float4: "double",
  float8: "double",
  numeric: "double",
  money: "double",
  // oid: "number",
  bool: "boolean",
  json: "JSON",
  // jsonb: 'JSONB',
  date: "datetime",
  timestamp: "datetime",
  timestamptz: "datetime",
  // point: "{ x: number, y: number }",
};

const TYPES = { ...MYSQL_TYPES, ...POSTGRES_TYPES };

const typing = (config: Config, { udtName }: ColumnDefinition, enumDefinitions: EnumDefinitions): string => {
  const type = TYPES[udtName];
  if (type && !["unknown"].includes(type)) {
    return type;
  }

  const enumDefinition = enumDefinitions.find(column => column.name === udtName)
  if(enumDefinition ) {
    const enumType = config.formatEnumName(enumDefinition.name)
    return `string; # enum: ${enumType}`
  }

  const warning = `Type [${udtName} has been mapped to [any] because no specific type has been found.`;
  if (config.throwOnMissingType) {
    throw new Error(warning);
  }
  console.warn(warning);
  return "any";
};

//------------------------------------------------------------------------------

const castHeader = async (config: Config, db: Database): Promise<string> => `
################################################################################
#
# AUTO-GENERATED FILE @ ${new Date().toUTCString()} - DO NOT EDIT!
#
# This file was automatically generated by schemats v.${config.version}
# $ ${config.getCLICommand(db.getConnectionString())}
#
################################################################################

${config.database}-entity sub entity, abstract;
${config.database}-relation sub relation, abstract;
${config.database}-attribute sub attribute, abstract;`;

//------------------------------------------------------------------------------

const Attribute = {
  name: (config: Config, { name }: ColumnDefinition): string =>
    config.formatColumnName(normalizeName(name)),

  type: (config: Config, record: ColumnDefinition): string =>
    `${config.database.toLowerCase()}-attribute`,
};

const Entity = {
  name: (config: Config, { name }: TableDefinition): string =>
    config.formatTableName(normalizeName(name)),

  type: (config: Config, record: TableDefinition): string =>
    `${config.database.toLowerCase()}-entity`,
};

const castEntity = (config: Config, enumDefinitions: EnumDefinitions) => (record: TableDefinition) => {
  const name = Entity.name(config, record);
  const attributes = record.columns.map(
    (column) =>
      `${Attribute.name(config, column)} sub ${Attribute.type(
        config,
        column
      )}, value ${typing(config, column, enumDefinitions)};`
  );
  const fields = record.columns.map(
    (column) => `  , owns ${Attribute.name(config, column)}`
  );
  return `${name} sub ${Entity.type(config, record)}\n${fields.join(
    "\n"
  )}\n;\n${attributes.join("\n")}`;
};

//------------------------------------------------------------------------------
const findTableColumnType = (
  tableDefinitions: TableDefinitions,
  tableName: string,
  columnName: string
) => {
  const table = tableDefinitions.find(({ name }) => name === tableName);
  const column = table?.columns.find(({ name }) => name === columnName);
  return column?.udtName;
};

const attributeGroupingPairs = (tableDefinitions: TableDefinitions) => {
  const tableColumnNames = uniq(
    flatMap(
      tableDefinitions.map(({ columns }) => columns.map(({ name }) => name))
    )
  );

  const pairs = tableColumnNames.map((columnName) => {
    const tables = tableDefinitions.filter(({ columns }) =>
      columns.map(({ name }) => name).includes(columnName)
    );
    const tableNames = tables.map(({ name }) =>
      // name
      [findTableColumnType(tableDefinitions, name, columnName), name].join("::")
    );
    return [columnName, tableNames.sort()];
  });

  return sortBy(pairs, ([key, values]) => values.length);
};

const attributeOverlapGrouping = (tableDefinitions: TableDefinitions) => {
  const groupingPairs = attributeGroupingPairs(tableDefinitions);
  return fromPairs(groupingPairs.filter(([key, values]) => values.length > 1));
};

const castOverlapHeader = (overlaps: Record<string, string[]>) => `
################################################################################
# Overlapping keys
################################################################################
${JSON.stringify(overlaps, null, 2)
  .split("\n")
  .map((line) => `# ${line}`)
  .join("\n")}
################################################################################
`;

const overlapHeader = (config: Config, tableDefinitions: TableDefinitions) => {
  const overlaps = attributeOverlapGrouping(tableDefinitions);
  const userOverlaps = omit(overlaps, config.ignoreFieldCollisions);
  if (!config.ignoreFieldCollisions.includes("*") && size(userOverlaps) > 0) {
    return castOverlapHeader(userOverlaps);
  }
  return `
#-------------------------------------------------------------------------------
  `;
};

export const typedbOfSchema = async (
  config: Config,
  db: Database,
  schema: string,
  tableDefinitions: TableDefinitions,
  enumDefinitions: EnumDefinitions,
  customTypes: CustomTypes
) => {
  const header = await castHeader(config, db);
  const entities = flatMap(tableDefinitions, castEntity(config, enumDefinitions));
  const overlaps = overlapHeader(config, tableDefinitions);

  // assertUniqEntities(config, tableDefinitions)
  // assertUniqAttributesAndTypes( config, overlaps)

  return [header, overlaps, entities.join("\n\n")].join("\n");
};
