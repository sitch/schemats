import { identity, flatMap, size } from "lodash";
import { Config } from "../config";
import { banner, commentLines, pretty } from "../formatters";
import { BuildContext } from "../generator";
import { TypeDBCoreferences, castTypeDBCoreferences } from "../coreference";
import { castTypeDBType, isReservedWord } from "../typemaps/typedb-typemap";
import {
  ColumnDefinition,
  ForeignKey,
  TableDefinition,
} from "../adapters/types";

//------------------------------------------------------------------------------

const normalizeName = (name: string): string =>
  isReservedWord(name) ? `${name}_` : name;

//------------------------------------------------------------------------------

const castHeader = ({ config }: BuildContext): string => `
################################################################################
#
# AUTO-GENERATED FILE @ ${config.timestamp} - DO NOT EDIT!
#
# This file was automatically generated by schemats v.${config.version}
# $ ${config.commandFromCLI}
#
################################################################################

${config.database}-entity sub entity, abstract;
${config.database}-relation sub relation, abstract;
${config.database}-attribute sub attribute, abstract;`;

//------------------------------------------------------------------------------

const castCoreferenceMapHeader = ({
  all,
  error,
  warning,
}: TypeDBCoreferences) => `
################################################################################
# ⛔ CRITICAL ⛔ - (${size(error)}) - TypeDB Attribute Conflicts
################################################################################
${commentLines("#", pretty(error))}
#===============================================================================
# ⚠️ WARNING ⚠️ - (${size(warning)}) - UDT Conflicts
#===============================================================================
${commentLines("#", pretty(warning))}
#-------------------------------------------------------------------------------
# ❎ INFO ❎ - (${size(all)}) - TypeDB Attribute Overlaps
#-------------------------------------------------------------------------------
${commentLines("#", pretty(all))}
################################################################################
`;

const prefix = (config: Config) => {
  return config.database.toLowerCase();
};

//------------------------------------------------------------------------------

const Entity = {
  name: ({ config }: BuildContext, { name }: TableDefinition): string => {
    return normalizeName(config.formatEntityName(name));
  },
  type: ({ config }: BuildContext, table: TableDefinition): string => {
    return `${prefix(config)}-entity`;
  },
  field:
    (context: BuildContext) =>
    (column: ColumnDefinition): string => {
      const name = Attribute.name(context, column);
      return `  , owns ${name}`;
    },
};

const castEntity = (context: BuildContext) => (record: TableDefinition) => {
  const name = Entity.name(context, record);
  const type = Entity.type(context, record);
  const columns = record.columns;

  const fields = columns.map(Entity.field(context));
  const attributes = columns.map(castAttribute(context));

  return `${name} sub ${type}\n${fields.join("\n")}\n;\n${attributes.join(
    "\n"
  )}`;
};

//------------------------------------------------------------------------------

const Attribute = {
  name: ({ config }: BuildContext, { name }: ColumnDefinition): string => {
    return normalizeName(config.formatAttributeName(name));
  },
  type: ({ config }: BuildContext, record: ColumnDefinition): string => {
    return `${prefix(config)}-attribute`;
  },
};

const castAttribute = (context: BuildContext) => (column: ColumnDefinition) => {
  const name = Attribute.name(context, column);
  const type = Attribute.type(context, column);
  const value = castTypeDBType(context, column);
  return `${name} sub ${type}, value ${value};`;
};

//------------------------------------------------------------------------------

const Relation = {
  name: (
    { config }: BuildContext,
    {
      primaryTable,
      primaryColumn,
      foreignTable,
      foreignColumn,
      constraint,
    }: ForeignKey
  ): string => {
    const tableSource = config.formatRelationName(primaryTable);
    const attributeSource = config.formatRelationName(primaryColumn);
    const tableDest = config.formatRelationName(foreignTable);
    const attributeDest = config.formatRelationName(foreignColumn);

    return normalizeName(
      `${tableSource}-${attributeSource}-${tableDest}-${attributeDest}`
    );
  },
  type: ({ config }: BuildContext, table: ForeignKey): string => {
    return `${prefix(config)}-relation`;
  },
};

const castRelation = (context: BuildContext) => (record: ForeignKey) => {
  const { config } = context;
  const {
    primaryTable,
    primaryColumn,
    foreignTable,
    foreignColumn,
    constraint,
  } = record;

  const name = Relation.name(context, record);
  const type = Relation.type(context, record);
  const comment = `# Source: '${config.schema}.${constraint}'`;
  const relations = [
    `  , owns ${config.formatAttributeName(primaryColumn)}`,
    `  , owns ${config.formatAttributeName(foreignColumn)}`,
    `  , relates ${config.formatEntityName(primaryTable)}`,
    `  , relates ${config.formatEntityName(foreignTable)}`,
  ];

  return `${comment}\n${name} sub ${type}\n${relations.sort().join("\n")}\n;`;
};

//------------------------------------------------------------------------------

export const typedbOfSchema = async (context: BuildContext) => {
  const tables = context.tables;
  const foreignKeys = context.foreignKeys.flat();
  const entities = flatMap(tables, castEntity(context));
  const relationships = flatMap(foreignKeys, castRelation(context));
  const typeDBCoreferences = castTypeDBCoreferences(context);

  return [
    context.config.writeHeader ? [castHeader(context)] : [],
    size(typeDBCoreferences.all) > 0
      ? [castCoreferenceMapHeader(typeDBCoreferences)]
      : [],
    [banner("#", `Entities (${size(tables)})`)],
    [entities.join("\n\n")],
    size(foreignKeys) > 0
      ? [
          banner("#", `Relations (${size(foreignKeys)})`),
          relationships.join("\n\n"),
        ]
      : [],
  ]
    .flat()
    .filter(identity)
    .join("\n");
};
