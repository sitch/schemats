import { Config } from "../config";
import { flatMap } from "lodash";
import {

  EnumDefinition,
  TableDefinition,
  ColumnDefinition,
  EnumDefinitions,
  TableDefinitions,
  CustomType,
  CustomTypes,
  Coreferences,
} from "../adapters/types";
import { BuildContext } from "../generator";

//------------------------------------------------------------------------------

const reservedJSNames = new Set(["string", "number", "package"]);
const normalizeName = (name: string): string =>
  reservedJSNames.has(name) ? `${name}_` : name;

//------------------------------------------------------------------------------

const MYSQL_TYPES: Record<string, string> = {
  char: "string",
  varchar: "string",
  text: "string",
  tinytext: "string",
  mediumtext: "string",
  longtext: "string",
  time: "string",
  geometry: "string",
  set: "string",
  enum: "string",
  integer: "number",
  int: "number",
  smallint: "number",
  mediumint: "number",
  bigint: "number",
  double: "number",
  decimal: "number",
  numeric: "number",
  float: "number",
  year: "number",
  tinyint: "boolean",
  json: "JSON",
  date: "Date",
  datetime: "Date",
  timestamp: "Date",
  tinyblob: "string",
  mediumblob: "string",
  longblob: "string",
  blob: "string",
  binary: "string",
  varbinary: "string",
  bit: "string",
};

const POSTGRES_TYPES: Record<string, string> = {
  bpchar: "string",
  char: "string",
  varchar: "string",
  text: "string",
  citext: "string",
  uuid: "string",
  bytea: "string",
  inet: "string",
  time: "string",
  timetz: "string",
  interval: "string",
  tsvector: "string",
  mol: "string",
  bit: "string",
  bfp: "string",
  name: "string",
  int2: "number",
  int4: "number",
  int8: "number",
  float4: "number",
  float8: "number",
  numeric: "number",
  money: "number",
  oid: "number",
  bool: "boolean",
  json: "JSON",
  jsonb: "JSONB",
  date: "Date",
  timestamp: "Date",
  timestamptz: "Date",
  point: "{ x: number, y: number }",
};

const TYPES = { ...MYSQL_TYPES, ...POSTGRES_TYPES };

const typing = (
  config: Config,
  { name, udtName }: ColumnDefinition,
  enums: EnumDefinitions
): string => {
  const type = TYPES[udtName];
  if (type && !["unknown"].includes(type)) {
    return type;
  }

  const enumDefinition = enums.find(
    (column) => column.name === udtName
  );
  if (enumDefinition) {
    return config.formatEnumName(enumDefinition.name);
  }

  const warning = `Type [${udtName} has been mapped to [any] because no specific type has been found.`;
  if (config.throwOnMissingType) {
    throw new Error(warning);
  }
  console.warn(warning);
  return "any";
};

const translateType = (
  config: Config,
  record: ColumnDefinition,
  enums: EnumDefinitions
): string => {
  const type = typing(config, record, enums);
  return `${type}${record.isArray ? "[]" : ""}${
    record.nullable ? " | null" : ""
  }`;
};

//------------------------------------------------------------------------------

const castHeader = async ({config}: BuildContext): Promise<string> => `
/**
 * AUTO-GENERATED FILE @ ${config.timestamp} - DO NOT EDIT!
 *
 * This file was automatically generated by schemats v.${config.version}
 * $ ${config.commandFromCLI}
 *
 */`;

//------------------------------------------------------------------------------



const Enums = {
  name: ({config}: BuildContext, { table, name, column }: EnumDefinition): string =>
    normalizeName(config.formatEnumName(`${name}`)),

  key: ({config}: BuildContext, value: string): string => value,

  value: ({config}: BuildContext, value: string): string => value,
};

const castEnumAsEnum = (context: BuildContext) => (record: EnumDefinition) => {
  const entries = Array.from(record.values).map(
    (value: string) =>
      `  '${Enums.key(context, value)}' = '${Enums.value(context, value)}'`
  );
  return `export enum ${Enums.name(context, record)} {\n${entries.join(
    ",\n"
  )}\n}`;
};

const castEnumAsType = (context: BuildContext) => (record: EnumDefinition) => {
  const entries = Array.from(record.values).map(
    (value: string) => `'${value}'`
  );
  return `export type ${Enums.name(context, record)} = ${entries.join(" | ")}`;
};

const castEnum =
(context: BuildContext) =>

  (record: EnumDefinition): string => {
    if (context.config.enums) {
      return castEnumAsEnum(context)(record);
    }
    return castEnumAsType(context)(record);
  };

//------------------------------------------------------------------------------

const Interface = {
  name: ({config}: BuildContext, { name }: TableDefinition): string =>
    normalizeName(config.formatTableName(name)),

  key: ({config}: BuildContext, { name, nullable }: ColumnDefinition): string =>
    `${normalizeName(config.formatColumnName(name))}${nullable ? "?" : ""}`,

  value: (
    {config, enums}: BuildContext,
    record: ColumnDefinition
  ): string => translateType(config, record, enums),
};

const castInterface =
(context: BuildContext)=>
  (record: TableDefinition) => {
    const name = Interface.name(context, record);
    const fields = Object.values(record.columns).map(
      (column) =>
        `  ${Interface.key(context, column)}: ${Interface.value(
          context,
          column
        )}`
    );
    return `export interface ${name} {\n${fields.join("\n")}\n}`;
  };

//------------------------------------------------------------------------------

const castCustom =
({config, tables}: BuildContext)  =>
  (record: CustomType): string =>
    `import { ${Array.from(record).join(", ")} } from '${
      config.typesFile
    }'\n\n`;

//------------------------------------------------------------------------------

export const castLookup = (
  {config, tables}: BuildContext
): string => {
  const types = Object.values(tables).map(
    ({ name }) => `  ${name}: ${normalizeName(config.formatTableName(name))}`
  );
  return `export interface Tables {\n${types.join(",\n")}\n}`;
};

//------------------------------------------------------------------------------

export const typescriptOfSchema = async (
  context: BuildContext,
  ) => {
  const header = await castHeader(context);
  const customs = flatMap(context.customTypes, castCustom(context));
  const enums = flatMap(context.enums, castEnum(context));
  const interfaces = flatMap(
    Object.values(context.tables),
    castInterface(context)
  );
  const lookup = castLookup(context);

  return [header, customs, enums, interfaces, lookup].flat().join("\n\n");
};
