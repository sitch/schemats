/* eslint-disable @typescript-eslint/no-non-null-assertion */

import { get, groupBy, keys, partition, sortBy } from 'lodash'

import type { Config } from '../../config'
import {
  divider_line,
  render_octo_definitions,
  render_octo_import,
} from '../../lang/julia'
import type {
  Neo4indexEdge,
  Neo4jNode,
  Neo4jNodeLabel,
  Neo4jReflection,
  Neo4jSpecification,
  NodeIdentityMap,
  NodeLabelsMap,
} from '../../lang/neo4j'
import { identifier_like } from '../../utils'
import { render_autogenerated_banner } from '../base'

//##############################################################################
// See: https://neo4j.com/docs/graphql-manual/current/type-definitions/types/
//##############################################################################
const JULIA_TYPES: Record<string, string> = {
  // See: https://neo4j.com/labs/apoc/4.4/overview/apoc.meta/apoc.meta.type/

  INTEGER: 'Int64',
  FLOAT: 'Float64',
  STRING: 'String',
  BOOLEAN: 'Boolean',
  // RELATIONSHIP: 'Relationship',
  // NODE: 'Node',
  // PATH: 'Path',
  NULL: 'Missing',
  UNKNOWN: 'Any',
  MAP: 'Dict',
  LIST: 'Array',
  // LIST: 'Array{String}',
  LOCAL_DATE_TIME: 'Dates.Datetime',

  // Int: 'Int32',
  // BigInt: 'Int64',
  // Float: 'Float32',
  // Boolean: 'Boolean',
  // ID: 'ID',
  //
}

function cast_node_struct(node_labels_map: NodeLabelsMap) {
  return ({
    properties: {
      name,
      // indexes,
      // constraints
    },
  }: Neo4jNode) => {
    // const index_fields = indexes.map(index => `    ${index}::Nullable{Any}`).sort()

    const label_fields = get(node_labels_map, name, []).map(
      ({
        property,
        type,
        // isIndexed,
        uniqueConstraint,
        existenceConstraint,
      }) => {
        let julia_type = JULIA_TYPES[type]
        if (uniqueConstraint) {
          julia_type = `Distinct{${julia_type}}`
        }
        if (!existenceConstraint) {
          julia_type = `Nullable{${julia_type}}`
        }
        return `    ${property}::${julia_type}`
      },
    )

    const fields = [
      // ...index_fields,
      ...label_fields,
    ].sort()

    const [id_fields, attribute_fields] = partition(fields, field => {
      const name = field.split('::')[0]!
      return identifier_like(name)
    })

    const field_lines = [
      ...sortBy(id_fields, field => field.split('::')[0].length),
      ...attribute_fields,
    ]
    const body = field_lines.length > 0 ? `\n${field_lines.join('\n')}\n` : ' '
    return `
Base.@kwdef mutable struct ${name} <: Neo4jNode${body}end
`
  }
}

function union_types(types: string[]) {
  if (types.length === 1) {
    return types[0]
  }
  if (types.length >= 2) {
    return `Union{${types.join(',')}}`
  }
  return 'Nothing'
}

function cast_edge_struct(node_identity_map: NodeIdentityMap) {
  return (name: string, relationships: Neo4indexEdge[]) => {
    const edges = relationships
      .map(({ start, end }) => ({
        start: node_identity_map.get(start)!,
        end: node_identity_map.get(end)!,
      }))
      .map(({ start, end }) => `Tuple{${start},${end}}`)
      .sort()

    return `
Base.@kwdef mutable struct ${name} <: Neo4jEdge
    edge::${union_types(edges)}
end
`
  }
}

//------------------------------------------------------------------------------

function cast_node_name({ properties: { name } }: Neo4jNode) {
  return `${name}`
}

function cast_edge_name({ type }: Neo4indexEdge) {
  return `${type}`
}

//##############################################################################

export const render_julia_octo_from_neo4j_json = (
  config: Config,
  { nodes, relationships }: Neo4jSpecification,
  node_labels: Neo4jNodeLabel[],
  _reflect: Neo4jReflection,
) => {
  nodes = sortBy(nodes, 'properties.name')
  const node_labels_map = groupBy(node_labels, 'label')
  const node_identity_map = new Map<number, string>()
  for (const node of nodes) node_identity_map.set(node.identity, node.properties.name)

  const node_names = nodes.map(node => cast_node_name(node)).sort()
  const edge_groups = groupBy(relationships, cast_edge_name)
  const edge_names = sortBy(keys(edge_groups), name => name)

  const names = [...node_names, ...edge_names]

  const node_structs = nodes.map(cast_node_struct(node_labels_map)).sort()
  const edge_structs = edge_names.map(name =>
    cast_edge_struct(node_identity_map)(name, edge_groups[name]),
  )

  const octo_imports = names.map(name => render_octo_import(name, name))
  const octo_definition = render_octo_definitions(octo_imports)

  return `${render_autogenerated_banner('#')}

module ckg

${node_names.map(name => `export ${name}`).join('\n')}
${edge_names.map(name => `export ${name}`).join('\n')}

using Dates

abstract type Neo4jNode end
abstract type Neo4jEdge end

const Distinct{T} = T
const Nullable{T} = Union{Missing,T}

${divider_line()}
# Nodes         (${node_structs.length})
${divider_line()}
${node_structs.join('')}
${divider_line()}
# Edges (${edge_structs.length})
${divider_line()}
${edge_structs.join('')}${octo_definition}

end
`
}
//##############################################################################
