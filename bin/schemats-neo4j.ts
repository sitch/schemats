/* eslint-disable @typescript-eslint/no-non-null-assertion */

import chalk from 'chalk'
import type { Command } from 'commander'
import fs from 'fs-extra'
import { get, groupBy, keys, partition, sortBy } from 'lodash'

import { render_autogenerated_banner } from '../src/backends/base'
import type { CommandOptions } from '../src/config'
import { render_octo_definitions, render_octo_import } from '../src/lang/julia'
import { identifier_like, read_json } from '../src/utils'

export const neo4j = (program: Command, _argv: string[]) => {
  program
    .command('neo4j')
    .description('Generate from neo4j json')
    .argument('<neo4j_config_json>', 'Neo4j json file')
    .argument('<neo4j_node_labels_json>', 'Neo4j json file')
    .argument('<output>', 'Destination file')
    .option('--json', "don't generate a header")
    .action(
      (
        neo4index_config_json: string,
        neo4index_node_labels_json: string,
        output: string,
        _options: CommandOptions,
      ) => {
        const [specification] = read_json<Neo4jSpecification[]>(neo4index_config_json)
        const node_specifications = read_json<Neo4jNodeLabel[]>(
          neo4index_node_labels_json,
        )
        const content = template(specification, node_specifications)
        fs.writeFileSync(output, content)
      },
    )

  program.action(() => console.error(chalk.red(program.helpInformation())))
}

//------------------------------------------------------------------------------

type NodeIdentityMap = Map<number, string>
type NodeLabelsMap = Record<string, Neo4jNodeLabel[]>

interface Neo4jNodeLabel {
  label: string
  property: string
  type: string
  // eslint-disable-next-line @typescript-eslint/naming-convention
  isIndexed: boolean
  // eslint-disable-next-line @typescript-eslint/naming-convention
  uniqueConstraint: boolean
  // eslint-disable-next-line @typescript-eslint/naming-convention
  existenceConstraint: boolean
}
interface Neo4jSpecification {
  nodes: Neo4jNode[]
  relationships: Neo4indexEdge[]
}

interface Neo4jNode {
  identity: number
  properties: Neo4jNodeProperties

  // Unused
  labels: string[]
}

interface Neo4jNodeProperties {
  name: string
  indexes: string[]
  constraints: string[]
}

interface Neo4indexEdge {
  identity: number
  start: number
  end: number
  type: string
  properties: Neo4indexEdgeProperties
}

type Neo4indexEdgeProperties = Record<string, never>

//##############################################################################
// See: https://neo4j.com/docs/graphql-manual/current/type-definitions/types/
//##############################################################################
const JULIA_TYPES: Record<string, string> = {
  // See: https://neo4j.com/labs/apoc/4.4/overview/apoc.meta/apoc.meta.type/

  INTEGER: 'Int64',
  FLOAT: 'Float64',
  STRING: 'String',
  BOOLEAN: 'Boolean',
  // RELATIONSHIP: 'Relationship',
  // NODE: 'Node',
  // PATH: 'Path',
  NULL: 'Missing',
  UNKNOWN: 'Any',
  MAP: 'Dict',
  LIST: 'Array',
  // LIST: 'Array{String}',
  LOCAL_DATE_TIME: 'Dates.Datetime',

  // Int: 'Int32',
  // BigInt: 'Int64',
  // Float: 'Float32',
  // Boolean: 'Boolean',
  // ID: 'ID',
  //
}

function cast_node_struct(node_labels_map: NodeLabelsMap) {
  return ({
    properties: {
      name,
      // indexes,
      // constraints
    },
  }: Neo4jNode) => {
    // const index_fields = indexes.map(index => `    ${index}::Nullable{Any}`).sort()

    const label_fields = get(node_labels_map, name, []).map(
      ({
        property,
        type,
        // isIndexed,
        uniqueConstraint,
        existenceConstraint,
      }) => {
        let julia_type = JULIA_TYPES[type]
        if (uniqueConstraint) {
          julia_type = `Distinct{${julia_type}}`
        }
        if (!existenceConstraint) {
          julia_type = `Nullable{${julia_type}}`
        }
        return `    ${property}::${julia_type}`
      },
    )

    const fields = [
      // ...index_fields,
      ...label_fields,
    ].sort()

    const [id_fields, attribute_fields] = partition(fields, field => {
      const name = field.split('::')[0]!
      return identifier_like(name)
    })

    const field_lines = [
      ...sortBy(id_fields, field => field.split('::')[0].length),
      ...attribute_fields,
    ]
    const body = field_lines.length > 0 ? `\n${field_lines.join('\n')}\n` : ' '
    return `
Base.@kwdef mutable struct ${name} <: Neo4jNode${body}end
`
  }
}

function union_types(types: string[]) {
  if (types.length === 1) {
    return types[0]
  }
  if (types.length >= 2) {
    return `Union{${types.join(',')}}`
  }
  return 'Nothing'
}

function cast_edge_struct(node_identity_map: NodeIdentityMap) {
  return (name: string, relationships: Neo4indexEdge[]) => {
    const edges = relationships
      .map(({ start, end }) => ({
        start: node_identity_map.get(start)!,
        end: node_identity_map.get(end)!,
      }))
      .map(({ start, end }) => `Tuple{${start},${end}}`)
      .sort()

    return `
Base.@kwdef mutable struct ${name} <: Neo4jEdge
    edge::${union_types(edges)}
end
`
  }
}

//------------------------------------------------------------------------------

function cast_node_name({ properties: { name } }: Neo4jNode) {
  return `${name}`
}

function cast_edge_name({ type }: Neo4indexEdge) {
  return `${type}`
}

//##############################################################################

const template = (
  { nodes, relationships }: Neo4jSpecification,
  node_labels: Neo4jNodeLabel[],
) => {
  nodes = sortBy(nodes, 'properties.name')
  const node_labels_map = groupBy(node_labels, 'label')
  const node_identity_map = new Map<number, string>()
  for (const node of nodes) node_identity_map.set(node.identity, node.properties.name)

  const node_names = nodes.map(node => cast_node_name(node)).sort()
  const edge_groups = groupBy(relationships, cast_edge_name)
  const edge_names = sortBy(keys(edge_groups), name => name)

  const names = [...node_names, ...edge_names]

  const node_structs = nodes.map(cast_node_struct(node_labels_map)).sort()
  const edge_structs = edge_names.map(name =>
    cast_edge_struct(node_identity_map)(name, edge_groups[name]),
  )

  const octo_imports = names.map(name => render_octo_import(name, name))
  const octo_definition = render_octo_definitions(octo_imports)

  return `${render_autogenerated_banner('#')}

module ckg

${node_names.map(name => `export ${name}`).join('\n')}
${edge_names.map(name => `export ${name}`).join('\n')}

using Dates

abstract type Neo4jNode end
abstract type Neo4jEdge end

const Distinct{T} = T
const Maybe{T} = Union{Missing,T}

#-------------------------------------------------------------------------------
# Nodes         (${node_structs.length})
#-------------------------------------------------------------------------------
${node_structs.join('')}
#-------------------------------------------------------------------------------
# Edges (${edge_structs.length})
#-------------------------------------------------------------------------------
${edge_structs.join('')}
${octo_definition}

end
`
}
//##############################################################################
